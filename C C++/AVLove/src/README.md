[назад](../)

*Ещё одно .md*

### Функционал
Есть (будет) функция ```to_list```, которая превращает дерево в "бамбук"



### Тесты
Основная тестирующаяся функция: ```insdel_test_##NAME``` которая находится в ```test.h``` \
Она производит ```count_of_test``` операций вставок/удалений и после каждой проходит дерево от $\text{b} \text{egin}()$ до $\text{e} \text{nd}()$. При чём удаление происходит с вероятностью ```chance_to_del```.

Если на момент подключения ```#include "test.h"``` есть макрос ```CHECKING```, то дерево будет сравниваться с библиотечным $set$:
* проверка на равенство множеств через  $a \in b$ и $b \in a$
* проверка на высоту для каждой вершины и проверка на AVL-ность через функцию ```calc_h```

В $main$ запускается цикл с разными ```chance_to_del```. \
Для корректности получаемой производительности, в функции ```insdel_test_##NAME``` происходит ```srand(seed);```, при этом в $main$ заранее генерируется массив $seed$-ов для каждого ```chance_to_del``` – поэтому в оригинальном $set$ и в текущей реализации AVL-дерева происходят одинаковые рандомные действия, что позволяет доверять полученному результату.

Было замечено сильное влияение ```-O2``` флага, поэтому, чтобы исключить выкидывание кода компилятором, в функции находится среднее кол-во элементов <$n$> в дереве в процессе "жизни". \
Для этого после каждого изменения дерева, происходит обход всех его элементов от $\text{b} \text{egin}()$ до $\text{e} \text{nd}()$ и увелечения счетчика ```curr_n++```. Затем значение <$n$>  $= \frac{\sum {\text{curr} \_ \text{n}}}{\text{count} \_ { {\text{of} \_ \text{test}}}}$записывается по указателю, в массив в $main$-е: ```not_optimize[chance_to_del]```.
По завершению теста, значения из массива ```not_optimize``` сворачиваются функцией ```accumulate``` и результат печатается на экран. \
При верной работе должны получаться одинаковые значения.

